name: Vokal AI Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'src/**/*.ts'
      - 'src/**/*.js'
      - 'test/**/*.ts'
      - 'test/**/*.js'
      - '*.ts'
      - '*.js'
      - '*.md'

concurrency:
  group: copilot-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  FORCE_COLOR: 1
  HUSKY: 0 # Disable Husky hooks in CI

jobs:
  copilot-review:
    name: AI Code Review
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: üì¶ Setup PNPM
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: üì¶ Install dependencies
        run: pnpm install

      - name: üß™ Run Tests
        run: pnpm test
        continue-on-error: true

      - name: üîç Lint Code
        run: pnpm run lint
        continue-on-error: true

      - name: üîç Vokal-specific Review Summary
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository
        with:
          script: |
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            // Categorize changed files by Vokal feature area
            const categories = {
              'voice-testing': [],
              'tts-services': [],
              'stt-services': [],
              'audio-processing': [],
              'ai-evaluation': [],
              'cli-interface': [],
              'configuration': [],
              'documentation': [],
              'workflows': [],
              'other': []
            };

            files.forEach(file => {
              const path = file.filename;
              if (path.includes('voice-bot-test') || path.includes('voice-test') || path.includes('voice-interaction')) {
                categories['voice-testing'].push(path);
              } else if (path.includes('tts') || path.includes('text-to-speech')) {
                categories['tts-services'].push(path);
              } else if (path.includes('stt') || path.includes('speech-to-text') || path.includes('streaming-stt')) {
                categories['stt-services'].push(path);
              } else if (path.includes('audio') || path.includes('mixer') || path.includes('recording') || path.includes('assets/')) {
                categories['audio-processing'].push(path);
              } else if (path.includes('ai-comparison') || path.includes('neurolink') || path.includes('evaluation')) {
                categories['ai-evaluation'].push(path);
              } else if (path.includes('cli/') || path.includes('cli.ts')) {
                categories['cli-interface'].push(path);
              } else if (path.includes('config') || path.endsWith('.json') || path.endsWith('.yml') || path.endsWith('.yaml')) {
                categories['configuration'].push(path);
              } else if (path.endsWith('.md') || path.includes('docs/')) {
                categories['documentation'].push(path);
              } else if (path.includes('.github/workflows/')) {
                categories['workflows'].push(path);
              } else {
                categories['other'].push(path);
              }
            });

            let summary = 'ü§ñ **Vokal AI Code Review Completed**\n\n';
            summary += '### üìã Changed Files by Feature Area:\n\n';

            Object.entries(categories).forEach(([category, files]) => {
              if (files.length > 0) {
                const emoji = {
                  'voice-testing': 'üé§',
                  'tts-services': 'üó£Ô∏è',
                  'stt-services': 'üëÇ',
                  'audio-processing': 'üîä',
                  'ai-evaluation': 'ü§ñ',
                  'cli-interface': '‚å®Ô∏è',
                  'configuration': '‚öôÔ∏è',
                  'documentation': 'üìö',
                  'workflows': 'üîÑ',
                  'other': 'üìÑ'
                }[category] || 'üìÑ';

                summary += `${emoji} **${category.replace('-', ' ').toUpperCase()}** (${files.length} files)\n`;
                files.forEach(file => summary += `   - \`${file}\`\n`);
                summary += '\n';
              }
            });

            summary += '### üîç Review Focus Areas:\n';
            summary += '- **Voice Testing**: Test execution, scenario handling, result validation\n';
            summary += '- **TTS/STT Services**: Provider integration, API calls, error handling\n';
            summary += '- **Audio Processing**: Mixing, recording, playback, format conversion\n';
            summary += '- **AI Evaluation**: Response analysis, comparison accuracy, prompt engineering\n';
            summary += '- **Security**: API key handling, file system safety, input validation\n';
            summary += '- **Performance**: Memory usage, streaming efficiency, async operations\n';
            summary += '- **Cross-Platform**: macOS/Linux compatibility, audio device handling\n\n';
            summary += 'üìù Check the **Files Changed** tab for detailed review of each file.\n';
            summary += 'üöÄ Ensure all Vokal features (TTS, STT, Audio Mixing, AI Evaluation) work seamlessly together!';

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summary
            });
